{"version":3,"file":"DatahubDataTypeStringValue.mjs","sources":["../../src/services/api/DataHub/ETLAttributeMaps/ETLAttributeMaps.ts","../../src/utils/helpers.ts","../../src/components/dataTypes/StringValue/DatahubDataTypeStringValue.vue"],"sourcesContent":["import {\n  httpClient,\n  type IDataTableQuery,\n  type IDataFetcherResponse,\n} from \"@actindo/core-ui\";\n\nimport { BASE_API } from \"../base\";\nimport type { IETLAttributeMapping } from \".\";\n\nconst MODULE_BASE_API = `${BASE_API}ETLAttributeMaps.`;\n\nexport const etlAttributeMapsApi = {\n  /** List all ETLAttributeMaps for a given ETLAttributeSetMap */\n  async getList(\n    query?: IDataTableQuery & {\n      attributeSetMapId: number;\n      hideInactive: boolean;\n    },\n  ): Promise<IDataFetcherResponse<IETLAttributeMapping>> {\n    return httpClient.post(`${MODULE_BASE_API}get`, query);\n  },\n};\n","import { useI18n } from \"vue-i18n\";\nimport type { INode } from \"@/models\";\nimport type { ITenantAttribute } from \"@/services/api/DataHub/Attributes\";\nimport type { ITenantETLProcess } from \"@/services/api/DataHub/ETLProcesses\";\nimport {\n  SOURCE_TYPE,\n  type ISourcePorts,\n  type ITenantETLAttributeMap,\n} from \"@/services/api/DataHub/ETLAttributeMaps\";\nimport type { ITenantAttributeGroup } from \"@/services/api/DataHub/Groups\";\n\nconst getPrefixedKey = (key: string | false, prefix = \"__\") =>\n  key ? prefix + key : \"\";\n\nexport const getTranslatableFieldName = ({\n  key,\n  scope,\n  language,\n  attribute: { scopable, multilanguage },\n}: {\n  key: string;\n  scope: string;\n  language: string;\n  attribute: ITenantAttribute;\n}) =>\n  getPrefixedKey(key, \"_\") +\n  getPrefixedKey(scopable && scope) +\n  getPrefixedKey(multilanguage && language);\n\nexport const getFormElementLabel = (\n  languageName: string,\n  scopeName: string,\n  attribute: ITenantAttribute,\n) => {\n  let ret = attribute.name;\n  if (!attribute.scopable && !attribute.multilanguage) {\n    return ret;\n  }\n\n  ret = ret + \" (\";\n  if (attribute.scopable && attribute.multilanguage) {\n    ret = `${ret}${languageName}|${scopeName}`;\n  } else if (attribute.multilanguage) {\n    ret = `${ret}${languageName}`;\n  } else {\n    ret = `${ret}${scopeName}`;\n  }\n  ret = ret + \")\";\n\n  return ret;\n};\n\nexport function getAttributeData(attr: ISourcePorts) {\n  if (attr.sourceType !== SOURCE_TYPE.EMPTY) {\n    return attr.sourceAttribute?.name ?? attr.sourceNativeField;\n  }\n\n  return !attr.sourceDataTypeInstance\n    ? \"\"\n    : useI18n().t(\"elt.constValueDataType\", {\n        value: attr.sourceDataTypeInstance.name,\n      });\n}\n\nexport function getSource(attr: ISourcePorts) {\n  return !attr.sourceLanguage && !attr.sourceScope\n    ? \"\"\n    : ` ( ${[attr.sourceLanguage.description, attr.sourceScope.name]\n        .filter(Boolean)\n        .join(\" / \")} )`;\n}\n\nexport function getDestination(attr?: ITenantETLAttributeMap) {\n  return !attr?.destinationLanguage && !attr?.destinationScope\n    ? \"\"\n    : ` ( ${[attr.destinationLanguage.description, attr.destinationScope.name]\n        .filter(Boolean)\n        .join(\" / \")} )`;\n}\n\nexport const etlProcessesFromTo = (row: ITenantETLProcess) =>\n  `${row.sourceEntityType.name} (${row.sourceEntityFriendlyIdentifier}) -> ${row.destinationEntityType.name} (${row.destinationEntityFriendlyIdentifier})`;\n\nexport const sourceAttributes = (row: ITenantETLProcess) => {\n  if (!row.etlAttributeMap.sourcePorts) {\n    return \"\";\n  }\n  return row.etlAttributeMap.sourcePorts\n    .map(({ sourceType, sourceAttribute, sourceNativeField }) => {\n      switch (sourceType) {\n        case 0:\n          return sourceAttribute.name;\n        case 2:\n          return useI18n().t(\"shared.constantValue\");\n        default:\n          return sourceNativeField;\n      }\n    })\n    .join(\", \");\n};\n\nexport const targetAttribute = (row: ITenantETLProcess) => {\n  switch (row.etlAttributeMap.destinationType) {\n    case 0:\n      return row.etlAttributeMap.destinationAttribute.name;\n    case 1:\n      return row.etlAttributeMap.destinationNativeField;\n    default:\n      return \"\";\n  }\n};\n\nexport const mapGroupToNode = (\n  data: ITenantAttributeGroup,\n  sortOrder: number,\n) => ({\n  id: data.id,\n  title: data.name,\n  children: data.children?.map(mapGroupToNode),\n  sortOrder,\n  data,\n});\n\nexport const getUniqId = (groupsList: INode[]) =>\n  Math.min(\n    0,\n    ...groupsList.flatMap(({ id, children = [] }) => [\n      id,\n      ...children.map((subGroup) => subGroup.id),\n    ]),\n  ) - 1;\n\nexport const collectCreated = (groupsList: INode[]) => {\n  return groupsList.reduce((result, group, index) => {\n    if (group.id < 0) {\n      const newGroup = {\n        ...group.data,\n        id: group.id,\n        sortOrder: index,\n        children: group.children?.map((subGroup, sortOrder) => ({\n          ...subGroup.data,\n          id: subGroup.id,\n          parent_id: group.id,\n          // active: true,\n          // \"[title]=new_test_sub_1\" ???\n          // \"[name]=new_test_sub_1\" ???\n          sortOrder,\n        })),\n      };\n\n      result.push(newGroup);\n    } else if (group.children?.length) {\n      group.children.forEach((subGroup, sortOrder) => {\n        if (subGroup.id < 0) {\n          const newGroup = {\n            ...subGroup.data,\n            id: subGroup.id,\n            parent_id: group.id,\n            sortOrder,\n            // active: true,\n            // \"[title]=new_test_sub_1\" ???\n            // \"[name]=new_test_sub_1\" ???\n          };\n\n          result.push(newGroup);\n        }\n      });\n    }\n\n    return result;\n  }, []);\n};\n\nexport const collectModified = (groupsList: INode[]) => {\n  return groupsList.reduce((result, group, index) => {\n    if (group.id < 0) {\n      return result;\n    }\n\n    if (group.data.updated || index !== group.sortOrder) {\n      const newGroup = {\n        ...group.data,\n        id: group.id,\n        sortOrder: index,\n        children: group.children?.map((subGroup, sortOrder) => ({\n          ...subGroup.data,\n          id: subGroup.id,\n          parent_id: group.id,\n          // active: true,\n          // \"[title]=new_test_sub_1\" ???\n          // \"[name]=new_test_sub_1\" ???\n          sortOrder,\n        })),\n      };\n\n      result.push(newGroup);\n    } else if (group.children?.length) {\n      group.children.forEach((subGroup, sortOrder) => {\n        if (\n          subGroup.id >= 0 &&\n          (subGroup.data.updated || sortOrder !== subGroup.sortOrder)\n        ) {\n          const newGroup = {\n            ...subGroup.data,\n            id: subGroup.id,\n            parent_id: group.id,\n            sortOrder,\n            // active: true,\n            // \"[title]=new_test_sub_1\" ???\n            // \"[name]=new_test_sub_1\" ???\n          };\n\n          result.push(newGroup);\n        }\n      });\n    }\n\n    return result;\n  }, []);\n};\n","<script setup lang=\"ts\">\nimport { computed, ref } from \"vue\";\nimport { ATextField } from \"@actindo/core-ui\";\nimport type { ITenantAttributeLanguage } from \"@/services/api/DataHub/Languages\";\nimport type { ITenantAttributeScope } from \"@/services/api/DataHub/Scopes\";\nimport type { ITenantAttribute } from \"@/services/api/DataHub/Attributes\";\nimport { getFormElementLabel } from \"@/utils/helpers\";\n\n// todo UNREADY\n\nconst props = defineProps<{\n  attributeLanguage: ITenantAttributeLanguage;\n  scope: ITenantAttributeScope;\n  attribute: ITenantAttribute;\n  formElementName: string;\n  // invalid: boolean;\n  // errorMessage: string;\n  // readOnly: boolean;\n  // massEditing?: boolean;\n  // multiVariants?: boolean;\n  // default data-type props\n  // fitInto: object;\n}>();\n\nconst formElementLabel = computed(() =>\n  getFormElementLabel(\n    props.attributeLanguage.description,\n    props.scope.name,\n    props.attribute,\n  ),\n);\n\nconst value = ref(\"\"); // todo - should we pass value from parent?\n</script>\n\n<template>\n  <ATextField\n    v-model=\"value\"\n    :readonly=\"attribute.configuration.readOnly\"\n    :name=\"formElementName\"\n    :label=\"formElementLabel\"\n  />\n  <!--  :error=\"invalid\"-->\n  <!--  :error-messages=\"errorMessage\"-->\n</template>\n"],"names":[],"mappings":"AAAA,OAAA,eAAA,EAAA;ACAA,OAAA,SAAA,EAAA;AA6BO,MAAM,sBAAsB,CACjC,cACA,WACA,cACG;AACH,MAAI,MAAM,UAAU;AACpB,MAAI,CAAC,UAAU,YAAY,CAAC,UAAU,eAAe;AAC5C,WAAA;AAAA,EACT;AAEA,QAAM,MAAM;AACR,MAAA,UAAU,YAAY,UAAU,eAAe;AACjD,UAAM,GAAG,GAAG,GAAG,YAAY,IAAI,SAAS;AAAA,EAAA,WAC/B,UAAU,eAAe;AAC5B,UAAA,GAAG,GAAG,GAAG,YAAY;AAAA,EAAA,OACtB;AACC,UAAA,GAAG,GAAG,GAAG,SAAS;AAAA,EAC1B;AACA,QAAM,MAAM;AAEL,SAAA;AACT;;;;;ACjDA,MAAA,WAAA,OAAA,KAAA,EAAA;;AACA,MAAA,aAAA,OAAA,eAAA,EAAA;;;;;;;;;;AAQA,UAAM,QAAQ;AAcd,UAAM,mBAAmB;AAAA,MAAS,MAChC;AAAA,QACE,MAAM,kBAAkB;AAAA,QACxB,MAAM,MAAM;AAAA,QACZ,MAAM;AAAA,MACR;AAAA,IAAA;AAGI,UAAA,QAAQ,IAAI,EAAE;;;;;;;;;;;;"}